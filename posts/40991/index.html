<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><link href="https://fastly.jsdelivr.net/npm/hexo-tag-common@0.1.0/css/index.css" rel="stylesheet"><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png"><link rel="icon" href="/img/fluid.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="author" content="AWEI"><meta name="keywords" content="AWEI,AWEI的技术小屋"><meta name="description" content="Docker 简介是什么docker 官网 docker 镜像仓库  问题：为什么会有 docker 出现？ 假定您在开发一个微服务系统，您使用的是一台笔记本电脑而且您的开发环境具有特定的配置。其他开发人员身处的环境配置也各有不同。您正在开发的应用依赖于您当前的配置且还要依赖于某些配置文件。此外，您的企业还拥有标准化的测试和生产环境，且具有自身的配置和一系列支持文件。您希望尽可能多在本地模拟这些环"><meta property="og:type" content="article"><meta property="og:title" content="Docker"><meta property="og:url" content="https://www.inencoding.com/posts/40991/index.html"><meta property="og:site_name" content="In-Encoding"><meta property="og:description" content="Docker 简介是什么docker 官网 docker 镜像仓库  问题：为什么会有 docker 出现？ 假定您在开发一个微服务系统，您使用的是一台笔记本电脑而且您的开发环境具有特定的配置。其他开发人员身处的环境配置也各有不同。您正在开发的应用依赖于您当前的配置且还要依赖于某些配置文件。此外，您的企业还拥有标准化的测试和生产环境，且具有自身的配置和一系列支持文件。您希望尽可能多在本地模拟这些环"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.inencoding.com/img/%E6%96%87%E7%AB%A0/docker.png"><meta property="article:published_time" content="2022-05-28T05:15:27.000Z"><meta property="article:modified_time" content="2022-12-08T15:28:22.391Z"><meta property="article:author" content="AWEI"><meta property="article:tag" content="容器"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://www.inencoding.com/img/%E6%96%87%E7%AB%A0/docker.png"><meta name="referrer" content="no-referrer-when-downgrade"><title>Docker - In-Encoding</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/fluid-extention.css"><script id="fluid-configs">var dntVal,Fluid=window.Fluid||{},CONFIG=(Fluid.ctx=Object.assign({},Fluid.ctx),{hostname:"www.inencoding.com",root:"/",version:"1.9.2",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!1,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"https://cdn.jsdelivr.net/gh/AWeiIsCoding/AWeiIsCoding.github.io/local-search.xml"});CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><style>.spoiler{display:inline-flex}p.spoiler{display:flex}.spoiler a{pointer-events:none}.spoiler-blur,.spoiler-blur>*{transition:text-shadow .5s ease}.spoiler .spoiler-blur,.spoiler .spoiler-blur>*{color:transparent;background-color:rgba(0,0,0,0);text-shadow:0 0 10px grey;cursor:pointer}.spoiler .spoiler-blur:hover,.spoiler .spoiler-blur:hover>*{text-shadow:0 0 5px grey}.spoiler-box,.spoiler-box>*{transition:color .5s ease,background-color .5s ease}.spoiler .spoiler-box,.spoiler .spoiler-box>*{color:#000;background-color:#000;text-shadow:none}</style><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="In-Encoding" type="application/atom+xml"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>InEncoding</strong></a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(https://inencoding.oss-cn-shenzhen.aliyuncs.com/img/background.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="Docker"></span></div><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> AWEI</span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-05-28 13:15" pubdate>2022年5月28日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 15k 字</span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 128 分钟</span><span id="busuanzi_container_page_pv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar category-bar" style="margin-right:-1rem"><div class="category-list"><div class="category row nomargin-x"><a class="category-item list-group-item category-item-action col-10 col-md-11 col-xm-11" title="学习笔记" id="heading-078425eaf316a180b0989442e53f920b" role="tab" data-toggle="collapse" href="#collapse-078425eaf316a180b0989442e53f920b" aria-expanded="true">学习笔记 <span class="list-group-count">(22)</span><i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse show" id="collapse-078425eaf316a180b0989442e53f920b" role="tabpanel" aria-labelledby="heading-078425eaf316a180b0989442e53f920b"><div class="category-post-list"><a href="/posts/53027/" title="Ajax 和 Json" class="list-group-item list-group-item-action"><span class="category-post">Ajax 和 Json</span></a> <a href="/posts/40991/" title="Docker" class="list-group-item list-group-item-action active"><span class="category-post">Docker</span></a> <a href="/posts/22111/" title="JQuery 学习笔记" class="list-group-item list-group-item-action"><span class="category-post">JQuery 学习笔记</span></a> <a href="/posts/43258/" title="Java 多线程学习笔记" class="list-group-item list-group-item-action"><span class="category-post">Java 多线程学习笔记</span></a> <a href="/posts/12475/" title="Java 注解与反射" class="list-group-item list-group-item-action"><span class="category-post">Java 注解与反射</span></a> <a href="/posts/15254/" title="Java 网络编程学习笔记" class="list-group-item list-group-item-action"><span class="category-post">Java 网络编程学习笔记</span></a> <a href="/posts/16781/" title="JavaWeb 学习笔记" class="list-group-item list-group-item-action"><span class="category-post">JavaWeb 学习笔记</span></a> <a href="/posts/33152/" title="MyBatis-Plus" class="list-group-item list-group-item-action"><span class="category-post">MyBatis-Plus</span></a> <a href="/posts/39805/" title="MySQL 学习笔记" class="list-group-item list-group-item-action"><span class="category-post">MySQL 学习笔记</span></a> <a href="/posts/15608/" title="Mybatis" class="list-group-item list-group-item-action"><span class="category-post">Mybatis</span></a> <a href="/posts/27273/" title="Redis" class="list-group-item list-group-item-action"><span class="category-post">Redis</span></a> <a href="/posts/18155/" title="Spring" class="list-group-item list-group-item-action"><span class="category-post">Spring</span></a> <a href="/posts/46897/" title="Spring MVC" class="list-group-item list-group-item-action"><span class="category-post">Spring MVC</span></a> <a href="/posts/33757/" title="SpringBoot" class="list-group-item list-group-item-action"><span class="category-post">SpringBoot</span></a> <a href="/posts/42622/" title="SpringCloud" class="list-group-item list-group-item-action"><span class="category-post">SpringCloud</span></a> <a href="/posts/43782/" title="Vue" class="list-group-item list-group-item-action"><span class="category-post">Vue</span></a> <a href="/posts/43167/" title="git" class="list-group-item list-group-item-action"><span class="category-post">git</span></a> <a href="/posts/62461/" title="python 爬虫" class="list-group-item list-group-item-action"><span class="category-post">python 爬虫</span></a> <a href="/posts/13607/" title="基于 Centos6.5 的 Httpd 安装" class="list-group-item list-group-item-action"><span class="category-post">基于 Centos6.5 的 Httpd 安装</span></a> <a href="/posts/6262/" title="基于 Centos6.8 的 Hadoop 分布式集群安装" class="list-group-item list-group-item-action"><span class="category-post">基于 Centos6.8 的 Hadoop 分布式集群安装</span></a> <a href="/posts/59309/" title="基于 Centos7 的 Zookeeper 安装" class="list-group-item list-group-item-action"><span class="category-post">基于 Centos7 的 Zookeeper 安装</span></a> <a href="/posts/13858/" title="软件工程随笔" class="list-group-item list-group-item-action"><span class="category-post">软件工程随笔</span></a></div></div></div></div></aside></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">Docker</h1><p class="note note-warning">本文最后更新于：2022年12月8日 晚上</p><div class="markdown-body"><h1 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker 简介</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p><a target="_blank" rel="noopener" href="http://www.docker.com/">docker 官网</a></p><p><a target="_blank" rel="noopener" href="https://hub.docker.com/">docker 镜像仓库</a></p><ul><li><p>问题：为什么会有 docker 出现？</p><p>假定您在开发一个微服务系统，您使用的是一台笔记本电脑而且您的开发环境具有特定的配置。其他开发人员身处的环境配置也各有不同。您正在开发的应用依赖于您当前的配置且还要依赖于某些配置文件。此外，您的企业还拥有标准化的测试和生产环境，且具有自身的配置和一系列支持文件。您希望尽可能多在本地模拟这些环境而不产生重新创建服务器环境的开销。</p><p>请问：您要如何确保应用能够在这些环境中运行和通过质量检测？并且在部署过程中不出现令人头疼的版本、配置问题，也无需重新编写代码和进行故障修复？</p><p><strong>答案就是使用容器</strong>。Docker 之所以发展如此迅速，也是因为它对此给出了一个标准化的解决方案 —–<strong>系统平滑移植，容器虚拟化技术</strong>。</p><p>环境配置相当麻烦，换一台机器，就要重来一次，费力费时。很多人想到，能不能从根本上解决问题，<strong>能否实现软件可以带环境安装</strong>？也就是说，<strong>安装的时候，把原始环境一模一样地复制过来。开发人员利用 Docker 可以消除协作编码时 “在我的机器上可正常工作” 的问题</strong>。</p><p>传统上认为，软件编码开发 / 测试结束后，所产出的成果即是程序或是能够编译执行的二进制字节码等 (Java 为例)。而为了让这些程序可以顺利执行，<strong>开发团队也得准备完整的部署文件，让维运团队得以部署应用程式，开发需要清楚的告诉运维部署团队，用的全部配置文件 + 所有软件环境。不过，即便如此，仍然常常发生部署失败的状况</strong>。Docker 的出现使得 Docker 得以<strong>打破过去「程序即应用」的观念。透过镜像 (images) 将作业系统核心除外，运作应用程式所需要的系统环境，由下而上打包，达到应用程式跨平台间的无缝接轨运作</strong>。</p></li><li><p>docker 理念</p><p><strong>Docker 是基于 Go 语言实现的云开源项目</strong>。</p><p>Docker 的主要目标是 “Build，Ship and Run Any App,Anywhere”，也就是通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的 APP（可以是一个 WEB 应用或数据库应用等等）及其运行环境能够做到 “<strong>一次镜像，处处运行</strong>”）。</p><p><img src="https://inencoding.oss-cn-shenzhen.aliyuncs.com/img/20220528141823.png" srcset="/img/loading.gif" lazyload alt="image-20220528141823015"></p><p><strong>Linux 容器技术的出现就解决了这样一个问题，而 Docker 就是在它的基础上发展过来的</strong>。将应用打成镜像，通过镜像成为运行在 Docker 容器上面的实例，而 Docker 容器在任何操作系统上都是一致的，这就实现了跨平台、跨服务器。<strong>只需要一次配置好环境，换到别的机子上就可以一键部署好，大大简化了操作</strong>。</p></li><li><p>一句话：就是解决了<strong>运行环境和配置问题</strong>的<strong>软件容器</strong>， 方便做持续集成并有助于整体发布的容器虚拟化技术。</p></li></ul><h2 id="容器与虚拟机比较"><a href="#容器与虚拟机比较" class="headerlink" title="容器与虚拟机比较"></a>容器与虚拟机比较</h2><ul><li><p>传统虚拟机技术</p><p>虚拟机（virtual machine）就是带环境安装的一种解决方案。</p><p>它可以在一种操作系统里面运行另一种操作系统，比如在 Windows10 系统里面运行 Linux 系统 CentOS7。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。这类虚拟机完美的运行了另一套系统，能够使应用程序，操作系统和硬件三者之间的逻辑不变。</p><p><img src="https://inencoding.oss-cn-shenzhen.aliyuncs.com/img/20220528142658.webp" srcset="/img/loading.gif" lazyload alt="img"></p><p>虚拟机的缺点：</p><ul><li>资源占用多</li><li>冗余步骤多</li><li>启动慢</li></ul></li><li><p>容器虚拟化技术</p><p>由于前面虚拟机存在某些缺点，Linux 发展出了另一种虚拟化技术：</p><p><strong>Linux 容器 (Linux Containers，缩写为 LXC)</strong></p><p>Linux 容器是与系统其他部分隔离开的一系列进程，从另一个镜像运行，并由该镜像提供支持进程所需的全部文件。容器提供的镜像包含了应用的所有依赖项，因而在从开发到测试再到生产的整个过程中，它都具有可移植性和一致性。</p><p><strong>Linux 容器不是模拟一个完整的操作系统</strong>而是对进程进行隔离。有了容器，就可以将软件运行所需的所有资源打包到一个隔离的容器中。<strong>容器与虚拟机不同，不需要捆绑一整套操作系统</strong>，只需要软件工作所需的库资源和设置。系统因此而变得高效轻量并保证部署在任何环境中的软件都能始终如一地运行。</p><p><img src="https://inencoding.oss-cn-shenzhen.aliyuncs.com/img/20220528142718.webp" srcset="/img/loading.gif" lazyload alt="img"></p></li><li><p>对比</p><p><img src="https://inencoding.oss-cn-shenzhen.aliyuncs.com/img/20220528142755.webp" srcset="/img/loading.gif" lazyload alt="img"></p><ul><li>传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；</li><li>容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核且也<strong>没有进行硬件虚拟</strong>。因此容器要比传统虚拟机更为轻便。</li><li>每个容器之间互相隔离，每个容器有自己的文件系统 ，容器之间进程不会相互影响，能区分计算资源。</li></ul></li></ul><h2 id="能干嘛"><a href="#能干嘛" class="headerlink" title="能干嘛"></a>能干嘛</h2><ul><li><p>更快速的应用交付和部署</p><p>传统的应用开发完成后，需要提供一堆安装程序和配置说明文档，安装部署后需根据配置文档进行繁杂的配置才能正常运行。Docker 化之后只需要交付少量容器镜像文件，在正式生产环境加载镜像并运行即可，应用安装配置在镜像里已经内置好，大大节省部署配置和测试验证时间。</p></li><li><p>更便捷的升级和扩缩容</p><p>随着微服务架构和 Docker 的发展，大量的应用会通过微服务方式架构，应用的开发构建将变成搭乐高积木一样，每个 Docker 容器将变成一块 “积木”，应用的升级将变得非常容易。当现有的容器不足以支撑业务处理时，可通过镜像运行新的容器进行快速扩容，使应用系统的扩容从原先的天级变成分钟级甚至秒级。</p></li><li><p>更简单的系统运维</p><p>应用容器化运行后，生产环境运行的应用可与开发、测试环境的应用高度一致，容器会将应用程序相关的环境和状态完全封装起来，不会因为底层基础架构和操作系统的不一致性给应用带来影响，产生新的 BUG。当出现程序异常时，也可以通过测试环境的相同容器进行快速定位和修复。</p></li><li><p>更高效的计算资源利用</p><p>Docker 是<strong>内核级虚拟化</strong>，其不像传统的虚拟化技术一样需要额外的 Hypervisor 支持，所以在一台物理机上可以运行很多个容器实例，可大大提升物理服务器的 CPU 和内存的利用率。</p></li><li><p>docker 应用场景</p><p><img src="https://inencoding.oss-cn-shenzhen.aliyuncs.com/img/20220528143200.png" srcset="/img/loading.gif" lazyload alt="image-20220528143200791"></p></li></ul><h1 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker 安装</h1><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p><strong>前提条件</strong></p><p>目前，CentOS 仅发行版本中的内核支持 Docker。Docker 运行在 CentOS 7 (64-bit) 上，</p><p>要求系统为 64 位、Linux 系统内核版本为 3.8 以上，这里选用 Centos7.x。</p><p><strong>查看自己的内核</strong></p><p>uname 命令用于打印当前系统相关信息（内核版本号、硬件架构、主机名称和操作系统类型等）。</p><h2 id="Docker的基本组成"><a href="#Docker的基本组成" class="headerlink" title="Docker的基本组成"></a>Docker 的基本组成</h2><ul><li><p>镜像 (image)</p><p>Docker 镜像（Image）就是一个<strong>只读</strong>的模板。镜像可以用来创建 Docker 容器，<strong>一个镜像可以创建很多容器</strong>。</p><p>它也相当于是一个 root 文件系统。比如官方镜像 centos:7 就包含了完整的一套 centos:7 最小系统的 root 文件系统。</p><p>相当于容器的 “源代码”，<strong>docker 镜像文件类似于 Java 的类模板，而 docker 容器实例类似于 java 中 new 出来的实例对象</strong>。</p></li><li><p>容器 (container)</p><p><strong>从面向对象角度</strong></p><p>Docker 利用容器（Container）独立运行的一个或一组应用，应用程序或服务运行在容器里面，容器就类似于一个虚拟化的运行环境，<strong>容器是用镜像创建的运行实例</strong>。就像是 Java 中的类和实例对象一样，镜像是静态的定义，容器是镜像运行时的实体。容器为镜像提供了一个标准的和隔离的运行环境，它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台</p><p><strong>从镜像容器角度</strong></p><p><strong>可以把容器看做是一个简易版的 Linux 环境</strong>（包括 root 用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。</p></li><li><p>仓库 (repository)</p><p>仓库（Repository）是集中存放镜像文件的场所。</p><p>类似于</p><p>Maven 仓库，存放各种 jar 包的地方；</p><p>github 仓库，存放各种 git 项目的地方；</p><p>Docker 公司提供的官方 registry 被称为 Docker Hub，存放各种镜像模板的地方。</p><p>仓库分为公开仓库（Public）和私有仓库（Private）两种形式。</p><p><strong>最大的公开仓库是</strong> <a target="_blank" rel="noopener" href="https://hub.docker.com/">Docker Hub</a>，</p><p>存放了数量庞大的镜像供用户下载。国内的公开仓库包括阿里云 、网易云等</p></li><li><p>总结</p><p><strong>需要正确的理解仓库 / 镜像 / 容器这几个概念</strong></p><p>Docker 本身是一个容器运行载体或称之为管理引擎。我们把应用程序和配置依赖打包好形成一个可交付的运行环境，这个打包好的运行环境就是 image 镜像文件。只有通过这个镜像文件才能生成 Docker 容器实例 (类似 Java 中 new 出来一个对象)。</p><p>image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。</p><p><strong>镜像文件</strong></p><p>image 文件生成的容器实例，本身也是一个文件，称为镜像文件。</p><p><strong>容器实例</strong></p><p>一个容器运行一种服务，当我们需要的时候，就可以通过 docker 客户端创建一个对应的运行实例，也就是我们的容器</p><p><strong>仓库</strong></p><p>就是放一堆镜像的地方，我们可以把镜像发布到仓库中，需要的时候再从仓库中拉下来就可以了。</p></li></ul><h2 id="Docker平台架构图解-架构版"><a href="#Docker平台架构图解-架构版" class="headerlink" title="Docker平台架构图解(架构版)"></a>Docker 平台架构图解 (架构版)</h2><p>Docker 是一个 C/S 模式的架构，后端是一个松耦合架构，众多模块各司其职。</p><p><img src="https://inencoding.oss-cn-shenzhen.aliyuncs.com/img/20220528150211.png" srcset="/img/loading.gif" lazyload alt="image-20220528150211519"></p><p><img src="https://inencoding.oss-cn-shenzhen.aliyuncs.com/img/20220528145355.png" srcset="/img/loading.gif" lazyload alt="image-20220528145355323"></p><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><div class="tag-common tabs" id="示例，[index]"><ul class="nav-tabs"><li class="tab active"><a data-target="示例，[index]-1">Centos 7</a></li><li class="tab"><a data-target="示例，[index]-2">Debian</a></li></ul><div class="tab-content"><div class="tab-pane active" id="示例，[index]-1"><ol><li><p>首先准备 CentOS7 系统</p></li><li><p>可以根据 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/install/centos">docker 官网下载 CentOS7 版本的 docker</a> 的步骤安装，也可以按照我下面的步骤进行</p></li><li><p>如果你之前安装过 docke，那么请卸载旧版本 docker</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 列出已经安装的 docker 相关软件</span><br>yum list installed | grep docker<br>rpm -qa | grep docker<br><br><span class="hljs-comment"># 删掉 docker 相关软件 列出几个就删几个</span><br>sudo yum -y remove docker-xxx.xxxxxx<br><br><span class="hljs-comment"># 删除镜像文件，容器</span><br><span class="hljs-built_in">rm</span> -rf /var/lib/docker<br><br><span class="hljs-comment"># 删除配置文件</span><br><span class="hljs-built_in">rm</span> -rf /etc/docker<br><br><span class="hljs-comment"># 通过脚本移除旧的版本</span><br>sudo yum remove docker \<br>                  docker-client \<br>                  docker-client-latest \<br>                  docker-common \<br>                  docker-latest \<br>                  docker-latest-logrotate \<br>                  docker-logrotate \<br>                  docker-selinux \<br>                  docker-engine-selinux \<br>                  docker-engine<br></code></pre></td></tr></tbody></table></figure></li><li><p>yum 安装 gcc 相关</p><ul><li>yum -y install gcc</li><li>yum -y install gcc-c++</li></ul></li><li><p>安装需要的软件包</p><p>yum install -y yum-utils</p></li><li><p>设置 stable 镜像仓库</p><p><code>yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</code></p></li><li><p>更新 yum 软件包索引</p><p><code>yum makecache fast</code></p></li><li><p>安装 docker CE</p><p><code>yum -y install docker-ce docker-ce-cli containerd.io</code></p></li><li><p>启动 docker</p><p><code>systemctl start docker</code></p></li><li><p>测试</p><p><code>docker version</code></p><p>测试结果</p><p><img src="https://inencoding.oss-cn-shenzhen.aliyuncs.com/img/20220529024243.png" srcset="/img/loading.gif" lazyload alt="image-20220529024243269"></p></li><li><p>执行 HelloWrold</p><p><code>docker run hello-world</code></p><p>测试结果</p><p><img src="https://inencoding.oss-cn-shenzhen.aliyuncs.com/img/20220529024411.png" srcset="/img/loading.gif" lazyload alt="image-20220529024411366"></p></li></ol></div><div class="tab-pane" id="示例，[index]-2"><ol><li><p>首先准备 Debian 系统</p></li><li><p>可以根据 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/install/debian">docker 官网下载 Debian 版本的 docker</a> 的步骤安装，也可以按照我下面的步骤进行</p></li><li><p>如果你之前安装过 docke，那么请卸载旧版本 docker</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get remove docker \<br>               docker-engine \<br>               docker.io<br></code></pre></td></tr></tbody></table></figure></li><li><p>安装必要工具</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get update<br><br>sudo apt-get install \<br>     apt-transport-https \<br>     ca-certificates \<br>     curl \<br>     gnupg \<br>     lsb-release<br></code></pre></td></tr></tbody></table></figure></li><li><p>添加软件源的 GPG 密钥</p><p><code>curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/debian/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</code></p></li><li><p>向 <code>sources.list</code> 中添加 Docker 软件源</p><p>在一些基于 Debian 的 Linux 发行版中 <code>$(lsb_release -cs)</code> 可能不会返回 Debian 的版本代号，例如 <a target="_blank" rel="noopener" href="https://www.kali.org/docs/policy/kali-linux-relationship-with-debian/">Kail Linux</a>、 <a target="_blank" rel="noopener" href="https://www.bunsenlabs.org/">BunsenLabs Linux</a>。在这些发行版中我们需要将下面命令中的 <code>$(lsb_release -cs)</code> 替换为 <a target="_blank" rel="noopener" href="https://mirrors.aliyun.com/docker-ce/linux/debian/dists/">阿里云 docker 镜像站</a> 中支持的 Debian 版本代号，例如 <code>buster</code>。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> \<br>  <span class="hljs-string">"deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/debian \</span><br><span class="hljs-string">  <span class="hljs-subst">$(lsb_release -cs)</span> stable"</span> | sudo <span class="hljs-built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null<br></code></pre></td></tr></tbody></table></figure></li><li><p>安装 docker</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get update<br><br>sudo apt-get install docker-ce docker-ce-cli containerd.io<br></code></pre></td></tr></tbody></table></figure></li><li><p>测试</p><p><code>docker version</code></p><p>测试结果</p><p><img src="https://inencoding.oss-cn-shenzhen.aliyuncs.com/img/20220804011417.png" srcset="/img/loading.gif" lazyload alt="image-20220804011417419"></p></li><li><p>启动 docker</p><p><code>systemctl start docker</code></p></li><li><p>执行 HelloWrold</p><p><code>docker run hello-world</code></p><p><img src="https://inencoding.oss-cn-shenzhen.aliyuncs.com/img/20220804011544.png" srcset="/img/loading.gif" lazyload alt="image-20220804011544008"></p></li></ol></div></div></div><h2 id="docker卸载"><a href="#docker卸载" class="headerlink" title="docker卸载"></a>docker 卸载</h2><div class="tag-common tabs" id="示例"><ul class="nav-tabs"><li class="tab active"><a data-target="示例-1">Centos 7</a></li><li class="tab"><a data-target="示例-2">Debian</a></li></ul><div class="tab-content"><div class="tab-pane active" id="示例-1"><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl stop docker<br><br>yum remove docker-ce docker-ce-cli containerd.io<br><br><span class="hljs-built_in">rm</span> -rf /var/lib/docker<br><br><span class="hljs-built_in">rm</span> -rf /var/lib/containerd<br></code></pre></td></tr></tbody></table></figure></div><div class="tab-pane" id="示例-2"><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl stop docker<br><br>sudo apt-get remove docker \<br>               docker-engine \<br>               docker.io<br></code></pre></td></tr></tbody></table></figure></div></div></div><h2 id="阿里云镜像加速"><a href="#阿里云镜像加速" class="headerlink" title="阿里云镜像加速"></a>阿里云镜像加速</h2><ol><li><p>打开<a target="_blank" rel="noopener" href="https://promotion.aliyun.com/ntms/act/kubernetes.html">阿里云云原生应用</a>，登录，选择<strong>控制台</strong>里的<strong>容器镜像服务</strong></p><p><img src="https://inencoding.oss-cn-shenzhen.aliyuncs.com/img/20220529032548.png" srcset="/img/loading.gif" lazyload alt="image-20220529031949121"></p></li><li><p>获得加速器地址：<a target="_blank" rel="noopener" href="https://jl2z4y5o.mirror.aliyuncs.com/">https://jl2z4y5o.mirror.aliyuncs.com</a></p><p><img src="https://inencoding.oss-cn-shenzhen.aliyuncs.com/img/20220529032039.png" srcset="/img/loading.gif" lazyload alt="image-20220529032039500"></p></li><li><p>root 权限下粘贴脚本直接执行</p></li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir -p /etc/docker<br><br>tee /etc/docker/daemon.json &lt;&lt;-'EOF'<br>{<br>  "registry-mirrors": ["https://jl2z4y5o.mirror.aliyuncs.com"]<br>}<br>EOF<br></code></pre></td></tr></tbody></table></figure><ol start="4"><li><p>重启服务器</p><ul><li><code>systemctl daemon-reload</code></li><li><code>systemctl restart docker</code></li></ul></li></ol><h2 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h2><p>启动 Docker 后台容器 (测试运行 hello-world)</p><p><code>docker run hello-world</code></p><p><img src="https://inencoding.oss-cn-shenzhen.aliyuncs.com/img/20220529032811.png" srcset="/img/loading.gif" lazyload alt="image-20220529032811648"></p><p>输出这段提示以后，hello world 就会停止运行，容器自动终止。</p><p><strong>那么 docker run 命令之后干了什么呢？</strong></p><p><img src="https://inencoding.oss-cn-shenzhen.aliyuncs.com/img/20220529113412.png" srcset="/img/loading.gif" lazyload alt="image-20220529113412857"></p><h2 id="底层对比"><a href="#底层对比" class="headerlink" title="底层对比"></a>底层对比</h2><p><strong>为什么 Docker 比 VM 虚拟机快？</strong></p><ul><li><p>docker 有着比虚拟机更少的抽象层</p><p>由于 docker 不需要 Hypervisor (虚拟机) 实现硬件资源虚拟化，运行在 docker 容器上的程序直接使用的都是实际物理机的硬件资源。因此在 CPU、内存利用率上 docker 将会在效率上有明显优势。</p></li><li><p>docker 利用的是宿主机的内核，而不需要加载操作系统 OS 内核</p><p>当新建一个容器时，docker 不需要和虚拟机一样重新加载一个操作系统内核。进而避免引寻、加载操作系统内核返回等比较费时费资源的过程，当新建一个虚拟机时，虚拟机软件需要加载 OS, 返回新建过程是分钟级别的。而 docker 由于直接利用宿主机的操作系统，则省略了返回过程，因此新建一个 docker 容器只需要几秒钟。</p></li></ul><h1 id="Docker常用命令"><a href="#Docker常用命令" class="headerlink" title="Docker常用命令"></a>Docker 常用命令</h1><h2 id="帮助启动类命令"><a href="#帮助启动类命令" class="headerlink" title="帮助启动类命令"></a>帮助启动类命令</h2><ul><li>启动 docker：<code>systemctl start docker</code></li><li>停止 docker：<code>systemctl stop docker</code></li><li>重启 docker：<code>systemctl restart docker</code></li><li>查看 docker 状态：<code>systemctl status docker</code></li><li>开机启动：<code>systemctl enable docker</code></li><li>查看 docker 概要信息：<code>docker info</code></li><li>查看 docker 总体帮助文档：<code>docker --help</code></li><li>查看 docker 命令帮助文档： <code>docker 具体命令 --help</code></li></ul><h2 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h2><ul><li><p><code>docker images [OPTIONS]</code></p><ul><li><p>作用：列出本地主机上的镜像</p><p><img src="https://inencoding.oss-cn-shenzhen.aliyuncs.com/img/20220529120008.png" srcset="/img/loading.gif" lazyload alt="image-20220529120008005"></p></li><li><p>各个选项卡说明</p><ul><li>REPOSITORY：表示镜像的仓库源</li><li>TAG：镜像的标签版本号<ul><li>同一仓库源可以有多个 TAG 版本，代表这个仓库源的不同个版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。</li><li>如果你不指定一个镜像的版本标签，例如你只使用 ubuntu，docker 将默认使用 ubuntu:latest 镜像</li></ul></li><li>IMAGE ID：镜像 ID</li><li>CREATED：镜像创建时间</li><li>SIZE：镜像大小</li></ul></li><li><p>OPTIONS 说明</p><ul><li>-a : 列出本地所有的镜像（含历史映像层）</li><li>-q : 只显示镜像 ID</li></ul></li></ul></li><li><p><code>docker search [OPTIONS] 某个XXX镜像名字</code></p><ul><li><p>作用：从 <a target="_blank" rel="noopener" href="https://hub.docker.com/">docker 仓库</a>查找镜像</p><p><img src="https://inencoding.oss-cn-shenzhen.aliyuncs.com/img/20220529121333.png" srcset="/img/loading.gif" lazyload alt="image-20220529121333713"></p></li><li><p>各个选项卡说明</p><ul><li>NAME：镜像名称</li><li>DESCRIPTION：镜像说明</li><li>STARS：点赞数量</li><li>OFFICIAL：是否属于官方</li><li>AUTOMATED：是否是自动构建的</li></ul></li><li><p>OPTIONS 说明</p><ul><li>–limit [N]：只列出 N 个镜像，默认 25 个</li></ul></li></ul></li><li><p><code>docker pull 某个XXX镜像名字</code></p><ul><li><p>作用：下载镜像</p></li><li><p>基本命令：<code>docker pull 镜像名字[:TAG]</code>，如果<strong>没有加上 TAG 代表默认取得最新版</strong>，等价于：<code>docker pull 镜像名字:latest</code></p><ul><li><p>例子：<code>docker pull ubuntu</code></p><p><img src="https://inencoding.oss-cn-shenzhen.aliyuncs.com/img/20220529122149.png" srcset="/img/loading.gif" lazyload alt="image-20220529122149769"></p></li></ul></li></ul></li><li><p><code>docker system df</code></p><ul><li><p>作用：查看镜像 / 容器 / 数据卷所占的空间</p><p><img src="https://inencoding.oss-cn-shenzhen.aliyuncs.com/img/20220529122341.png" srcset="/img/loading.gif" lazyload alt="image-20220529122341351"></p></li></ul></li><li><p><code>docker rmi 镜像名字ID</code></p><ul><li><p>作用：删除镜像</p></li><li><p>OPTIONS 说明</p><ul><li>-f：强制删除</li></ul></li><li><p>删除单个镜像：<code>docker rmi -f 镜像名字/镜像ID（唯一）</code></p><p><img src="https://inencoding.oss-cn-shenzhen.aliyuncs.com/img/20220529215213.png" srcset="/img/loading.gif" lazyload alt="image-20220529215213219"></p></li><li><p>删除多个镜像：<code>docker rmi -f 镜像名1:TAG 镜像名2:TAG</code></p></li><li><p>删除全部镜像（参数续传）：<code>docker rmi -f $(docker images -qa)</code></p></li></ul></li></ul><h2 id="面试题：docker虚悬镜像"><a href="#面试题：docker虚悬镜像" class="headerlink" title="面试题：docker虚悬镜像"></a>面试题：docker 虚悬镜像</h2><p><strong>是什么</strong></p><p>仓库名、标签都是 <code>&lt;none&gt;</code> 的镜像，俗称虚悬镜像 dangling image</p><p><img src="https://inencoding.oss-cn-shenzhen.aliyuncs.com/img/20220529215632.png" srcset="/img/loading.gif" lazyload alt="image-20220529215632374"></p><h2 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h2><p><strong>有镜像才能创建容器， 这是根本前提 (下载一个 CentOS 或者 ubuntu 镜像演示)</strong></p><ul><li><p><code>docker pull centos</code> 或者 <code>docker pull ubuntu</code></p></li><li><p>新建 + 启动容器</p><ul><li><p><code>docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</code></p></li><li><p>OPTIONS 说明（常用）：有些是一个减号，有些是两个减号</p><ul><li>–name=” 容器新名字”：为容器指定一个名称；</li><li>-d：后台运行容器并返回容器 ID，也即启动守护式容器 (后台运行)；</li><li>-i：以交互模式运行容器，通常与 -t 同时使用；</li><li>-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用。即启动交互式容器 (前台有伪终端，等待交互)；</li><li>-P：随机端口映射，大写 P；</li><li>-p：指定端口映射，小写 p；</li></ul></li><li><p>测试</p><ul><li><p>启动守护式容器</p><p><img src="https://inencoding.oss-cn-shenzhen.aliyuncs.com/img/20220529230019.png" srcset="/img/loading.gif" lazyload alt="image-20220529230019455"></p></li><li><p>启动交互式容器，在容器内执行 /bin/bash 命令，要退出终端，直接输入 exit</p><p><img src="https://inencoding.oss-cn-shenzhen.aliyuncs.com/img/20220529223826.png" srcset="/img/loading.gif" lazyload alt="image-20220529223826608"></p></li></ul></li></ul></li><li><p>列出当前所有正在运行的容器</p><ul><li><code>docker ps [OPTIONS]</code></li><li>OPTIONS 说明（常用）<ul><li>-a：列出当前所有正在运行的容器 + 历史上运行过的。</li><li>-l：显示最近创建的容器。</li><li>-n：显示最近 n 个创建的容器。</li><li>-q：静默模式，只显示容器编号。</li></ul></li></ul></li><li><p>退出容器</p><ul><li>两种退出方式<ul><li><code>exit</code>：exit 退出，容器停止</li><li>ctrl+p+q：ctrl+p+q 退出，容器不停止</li></ul></li></ul></li><li><p>启动已停止的容器</p><p><code>docker start 容器ID或者容器名</code></p></li><li><p>重启容器</p><p><code>docker restart 容器ID或者容器名</code></p></li><li><p>停止容器</p><p><code>docker stop 容器ID或者容器名</code></p></li><li><p>强制停止容器</p><p><code>docker kill 容器ID或容器名</code></p></li><li><p>删除已停止的容器</p><ul><li><code>docker rm 容器ID或容器名</code></li><li>OPTIONS 说明<ul><li>-f：强制删除</li></ul></li><li>一次性删除多个容器实例：<code>docker rm -f $(docker ps -a -q)</code> 或者 <code>docker ps -a -q | xargs docker rm</code></li></ul></li><li><p>查看容器日志</p><p><code>docker logs 容器ID</code></p></li><li><p>查看容器内运行的进程</p><p><code>docker top 容器ID</code></p></li><li><p>查看容器内部细节</p><p><code>docker inspect 容器ID</code></p></li><li><p>重新进入</p><ul><li><p>进入正在运行的容器并以<strong>命令行交互</strong></p><p><code>docker exec -it 容器ID commond</code></p></li><li><p>重新进入运行的容器</p><p><code>docker attach 容器ID</code></p></li><li><p>两者区别：</p><ul><li>attach 直接进入容器启动命令的终端，不会启动新的进程 用 exit 退出，会导致容器的停止</li><li>exec 是在容器中打开新的终端，并且可以启动新的进程 用 exit 退出，不会导致容器的停止</li></ul></li></ul></li><li><p>从容器内拷贝文件到主机上（容器→主机）</p><p><code>docker cp 容器ID:容器内路径 目的主机路径</code></p></li><li><p>导入和导出容器</p><ul><li><p><code>docker export 容器ID &gt; 文件名.tar</code> 导出容器的内容留作为一个 tar 归档文件 [对应 import 命令]</p></li><li><p>import 从 tar 包中的内容创建一个新的文件系统再导入为镜像 [对应 export]</p></li><li><p>示例</p><ul><li><p><code>docker export 容器ID &gt; 文件名.tar</code></p><p><img src="https://inencoding.oss-cn-shenzhen.aliyuncs.com/img/20220530165918.png" srcset="/img/loading.gif" lazyload alt="image-20220530165918049"></p></li><li><p><code>cat 文件名.tar | docker import - 镜像用户/镜像名:镜像版本号</code></p><p>首先删除容器</p><p><img src="https://inencoding.oss-cn-shenzhen.aliyuncs.com/img/20220530170256.png" srcset="/img/loading.gif" lazyload alt="image-20220530170256543"></p><p>利用 import 命令重新导入</p><p><img src="https://inencoding.oss-cn-shenzhen.aliyuncs.com/img/20220530170540.png" srcset="/img/loading.gif" lazyload alt="image-20220530170540215"></p><p>导入成镜像之后，重新启动 redis，执行成功</p><p><img src="https://inencoding.oss-cn-shenzhen.aliyuncs.com/img/20220530171356.png" srcset="/img/loading.gif" lazyload alt="image-20220530171356078"></p></li></ul></li></ul></li></ul><h2 id="守护式容器示例"><a href="#守护式容器示例" class="headerlink" title="守护式容器示例"></a>守护式容器示例</h2><p><strong>下载一个 Redis6.0.8 镜像演示</strong></p><ul><li><p>启动守护式容器 (后台服务器)：在大部分的场景下，我们希望 docker 的服务是在后台运行的， 我们可以过 -d 指定容器的后台运行模式。</p></li><li><p>使用 <code>docker run -d 容器名</code>启动容器</p><ul><li>问题：有些后台容器（例如 nginx、centos…）启动之后，使用 <code>docker ps -a</code> 进行查看，会发现容器已经退出.</li><li>原因：Docker 容器后台运行，就必须有一个前台进程。容器运行的命令如果不是那些一直挂起的命令（比如运行 top，tail），就是会自动退出的。</li><li>这个是 docker 的机制问题，比如你的 web 容器，我们以 nginx 为例，正常情况下，我们配置启动服务只需要启动响应的 service 即可。例如 <code>service nginx start</code> 但是，这样做，nginx 为后台进程模式运行，就导致 docker 前台没有运行的应用，这样的容器后台启动后，会立即自杀因为他觉得他没事可做了。所以，<strong>最佳的解决方案是，将你要运行的程序以前台进程的形式运行</strong>。</li></ul></li><li><p>启动 redis:6.0.8：<code>docker run -d redis:6.0.8</code>，查看容器启动情况：<code>docker ps</code></p><p><img src="https://inencoding.oss-cn-shenzhen.aliyuncs.com/img/20220530145159.png" srcset="/img/loading.gif" lazyload alt="image-20220530145159945"></p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p><strong>attach</strong></p><p>Attach to a running container</p><p>当前 shell 下 attach 连接指定运行镜像</p></li><li><p><strong>build</strong></p><p>Build an image from a Dockerfile</p><p>通过 Dockerfile 定制镜像</p></li><li><p><strong>commit</strong></p><p>Create a new image from a container changes</p><p>提交当前容器为新的镜像</p></li><li><p><strong>cp</strong></p><p>Copy files/folders from the containers filesystem to the host path</p><p>从容器中拷贝指定文件或者目录到宿主机中</p></li><li><p><strong>create</strong></p><p>Create a new container</p><p>创建一个新的容器，同 run，但不启动容器</p></li><li><p><strong>diff</strong></p><p>Inspect changes on a container’s filesystem</p><p>查看 docker 容器变化</p></li><li><p><strong>events</strong></p><p>Get real time events from the server</p><p>从 docker 服务获取容器实时事件</p></li><li><p><strong>exec</strong></p><p>Run a command in an existing container</p><p>在已存在的容器上运行命令</p></li><li><p><strong>export</strong></p><p>Stream the contents of a container as a tar archive</p><p>导出容器的内容流作为一个 tar 归档文件 [对应 import]</p></li><li><p><strong>history</strong></p><p>Show the history of an image</p><p>展示一个镜像形成历史</p></li><li><p><strong>images</strong></p><p>List images</p><p>列出系统当前镜像</p></li><li><p><strong>import</strong></p><p>Create a new filesystem image from the contents of a tarball</p><p>从 tar 包中的内容创建一个新的文件系统映像 [对应 export]</p></li><li><p><strong>info</strong></p><p>Display system-wide information</p><p>显示系统相关信息</p></li><li><p><strong>inspect</strong></p><p>Return low-level information on a container</p><p>查看容器详细信息</p></li><li><p><strong>kill</strong></p><p>Kill a running containe</p><p>kill 指定 docker 容器</p></li><li><p><strong>load</strong></p><p>Load an image from a tar archive</p><p>从一个 tar 包中加载一个镜像 [对应 save]</p></li><li><p><strong>login</strong></p><p>Register or Login to the docker registry server</p><p>注册或者登陆一个 docker 源服务器</p></li><li><p><strong>logout</strong></p><p>Log out from a Docker registry server</p><p>从当前 Docker registry 退出</p></li><li><p><strong>logs</strong></p><p>Fetch the logs of a container</p><p>输出当前容器日志信息</p></li><li><p><strong>port</strong></p><p>Lookup the public-facing port which is NAT-ed to PRIVATE_PORT</p><p>查看映射端口对应的容器内部源端口</p></li><li><p><strong>pause</strong></p><p>Pause all processes within a container</p><p>暂停容器</p></li><li><p><strong>ps</strong></p><p>List containers</p><p>列出容器列表</p></li><li><p><strong>pull</strong></p><p>Pull an image or a repository from the docker registry server</p><p>从 docker 镜像源服务器拉取指定镜像或者库镜像</p></li><li><p><strong>push</strong></p><p>Push an image or a repository to the docker registry server</p><p>推送指定镜像或者库镜像至 docker 源服务器</p></li><li><p><strong>restart</strong></p><p>Restart a running container</p><p>重启运行的容器</p></li><li><p><strong>rm</strong></p><p>Remove one or more containers</p><p>移除一个或者多个容器</p></li><li><p><strong>rmi</strong></p><p>Remove one or more images</p><p>移除一个或多个镜像 [无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]</p></li><li><p><strong>run</strong></p><p>Run a command in a new container</p><p>创建一个新的容器并运行一个命令</p></li><li><p><strong>save</strong></p><p>Save an image to a tar archive</p><p>保存一个镜像为一个 tar 包 [对应 load]</p></li><li><p><strong>search</strong></p><p>Search for an image on the Docker Hub</p><p>在 docker hub 中搜索镜像</p></li><li><p><strong>start</strong></p><p>Start a stopped containers</p><p>启动容器</p></li><li><p><strong>stop</strong></p><p>Stop a running containers</p><p>停止容器</p></li><li><p><strong>tag</strong></p><p>Tag an image into a repository</p><p>给源中镜像打标签</p></li><li><p><strong>top</strong></p><p>Lookup the running processes of a container</p><p>查看容器中运行的进程信息</p></li><li><p><strong>unpause</strong></p><p>Unpause a paused container</p><p>取消暂停容器</p></li><li><p><strong>version</strong></p><p>Show the docker version information</p><p>查看 docker 版本号</p></li><li><p><strong>wait</strong></p><p>Block until a container stops, then print its exit code</p><p>截取容器停止时的退出状态值</p></li></ul><h1 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker 镜像</h1><h2 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h2><p><strong>镜像</strong>是一种轻量级、可执行的独立软件包，它包含运行某个软件所需的所有内容，我们把应用程序和配置依赖打包好形成一个可交付的运行环境 (包括代码、运行时需要的库、环境变量和配置文件等)，这个打包好的运行环境就是 image 镜像文件。</p><p>只有通过这个镜像文件才能生成 Docker 容器实例 (类似 Java 中 new 出来一个对象)。</p><h2 id="镜像的分层"><a href="#镜像的分层" class="headerlink" title="镜像的分层"></a>镜像的分层</h2><p>以 <code>docker pull</code> 命令为例子，在下载的过程中可以看到 docker 的镜像好像是在一层一层的下载</p><p><img src="https://inencoding.oss-cn-shenzhen.aliyuncs.com/img/20220531143124.png" srcset="/img/loading.gif" lazyload alt="image-20220531143124176"></p><h2 id="UnionFS（联合文件系统）"><a href="#UnionFS（联合文件系统）" class="headerlink" title="UnionFS（联合文件系统）"></a>UnionFS（联合文件系统）</h2><p>UnionFS（联合文件系统）：Union 文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，<strong>它支持对文件系统的修改作为一次提交来一层层的叠加</strong>，同时可以将不同目录挂载到同一个虚拟文件系统下 (unite several directories into a single virtual filesystem)。Union 文件系统是 Docker 镜像的基础。<strong>镜像可以通过分层来进行继承</strong>，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p><p><strong>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。</strong></p><h2 id="Docker镜像加载原理"><a href="#Docker镜像加载原理" class="headerlink" title="Docker镜像加载原理"></a>Docker 镜像加载原理</h2><p>docker 的镜像实际上由一层一层的文件系统组成，这种层级的文件系统 UnionFS。</p><p>bootfs (boot file system) 主要包含 bootloader 和 kernel, bootloader 主要是引导加载 kernel, Linux 刚启动时会加载 bootfs 文件系统，<strong>在 Docker 镜像的最底层是引导文件系统 bootfs</strong>。这一层与我们典型的 Linux/Unix 系统是一样的，包含 boot 加载器和内核。当 boot 加载完成之后整个内核就都在内存中了，此时内存的使用权已由 bootfs 转交给内核，此时系统也会卸载 bootfs。</p><p>rootfs (root file system) ，在 bootfs 之上。包含的就是典型 Linux 系统中的 /dev, /proc, /bin, /etc 等标准目录和文件。rootfs 就是各种不同的操作系统发行版，比如 Ubuntu，Centos 等等。</p><p><img src="https://inencoding.oss-cn-shenzhen.aliyuncs.com/img/20220531143603.png" srcset="/img/loading.gif" lazyload alt="image-20220531143603105"></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><strong>为什么 docker 相较于虚拟机来说小很多？</strong></p><p>对于一个精简的 OS，rootfs 可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接用 Host 的 kernel，自己只需要提供 rootfs 就行了。由此可见对于不同的 linux 发行版，bootfs 基本是一致的，rootfs 会有差别，因此不同的发行版可以公用 bootfs。</p><p><strong>为什么 Docker 镜像要采用这种分层结构？</strong></p><p>镜像分层最大的一个好处就是共享资源，方便复制迁移，就是为了复用。</p><p>比如说有多个镜像都从相同的 base 镜像构建而来，那么 Docker Host 只需在磁盘上保存一份 base 镜像；</p><p>同时内存中也只需加载一份 base 镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。</p><h2 id="重点理解"><a href="#重点理解" class="headerlink" title="重点理解"></a>重点理解</h2><p><strong>Docker 镜像层都是只读的，容器层是可写的</strong></p><p>当容器启动时，一个新的可写层被加载到镜像的顶部。 这一层通常被称作 “容器层”，“容器层” 之下的都叫 “镜像层”。</p><p>当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称作 “容器层”，“容器层” 之下的都叫 “镜像层”。</p><p>所有对容器的改动 - 无论添加、删除、还是修改文件都只会发生在容器层中。只有容器层是可写的，容器层下面的所有镜像层都是只读的。</p><p><img src="https://inencoding.oss-cn-shenzhen.aliyuncs.com/img/20220531144037.png" srcset="/img/loading.gif" lazyload alt="image-20220531144037237"></p><h2 id="commit操作案例"><a href="#commit操作案例" class="headerlink" title="commit操作案例"></a>commit 操作案例</h2><p>作用：提交容器副本使之成为一个新的镜像</p><p><code>docker commit -m="提交的描述信息" -a="作者" 容器ID 要创建的目标镜像名:[标签名]</code></p><p><strong>案例演示 centos 安装 vim</strong></p><ul><li><p>从 Hub 上下载 centos 镜像到本地并成功运行，报错显示未联网</p><p><img src="https://inencoding.oss-cn-shenzhen.aliyuncs.com/img/20220531150853.png" srcset="/img/loading.gif" lazyload alt="image-20220531150853321"></p></li><li><p>解决无法联网问题</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">## 假设 sysctl.conf 文件不存在</span><br>vi /etc/sysctl.conf<br><span class="hljs-comment">## 在 sysctl.conf 中增加 net.ipv4.ip_forward = 1 , 表示允许进行路由转发</span><br>net.ipv4.ip_forward = 1<br><span class="hljs-comment">## 加载参数到内核</span><br>sysctl -p<br><span class="hljs-comment">## 退出容器</span><br><span class="hljs-built_in">exit</span><br><span class="hljs-comment">## 重启docker</span><br>systemctl restart docker<br></code></pre></td></tr></tbody></table></figure></li><li><p>原始的默认 centos 镜像是不带着 vim 命令</p><p><img src="https://inencoding.oss-cn-shenzhen.aliyuncs.com/img/20220531150908.png" srcset="/img/loading.gif" lazyload alt="image-20220531150908956"></p></li><li><p>外网连通的情况下，安装 vim：<code>yum install vim</code></p></li><li><p>安装完成后，commit 我们自己的新镜像</p><p><img src="https://inencoding.oss-cn-shenzhen.aliyuncs.com/img/20220531153022.png" srcset="/img/loading.gif" lazyload alt="image-20220531153022737"></p></li><li><p>启动新镜像并和原来的对比</p><ul><li>官网是默认下载的 centos 没有 vim 命令</li><li>我们自己 commit 构建的镜像，新增加了 vim 功能，可以成功使用</li></ul></li></ul><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>Docker 中的镜像分层，<strong>支持通过扩展现有镜像，创建新的镜像</strong>。类似 Java 继承于一个 Base 基础类，自己再按需扩展。</p><p>新镜像是从 base 镜像一层一层叠加生成的。每安装一个软件，就在现有镜像的基础上增加一层</p><h1 id="将本地镜像推送到阿里云"><a href="#将本地镜像推送到阿里云" class="headerlink" title="将本地镜像推送到阿里云"></a>将本地镜像推送到阿里云</h1><ul><li><p>打开<a target="_blank" rel="noopener" href="https://promotion.aliyun.com/ntms/act/kubernetes.html">阿里云开发者平台</a></p></li><li><p>创建仓库镜像</p><ul><li><p>选择容器镜像服务</p><p><img src="https://inencoding.oss-cn-shenzhen.aliyuncs.com/img/20220531153930.png" srcset="/img/loading.gif" lazyload alt="image-20220531153930394"></p></li><li><p>创建个人版仓库，设置密码、命名空间、仓库名字、公开仓库</p><p><img src="https://inencoding.oss-cn-shenzhen.aliyuncs.com/img/20220531154320.png" srcset="/img/loading.gif" lazyload alt="image-20220531154320849"></p></li></ul></li><li><p>在管理页面获得脚本</p><p><img src="https://inencoding.oss-cn-shenzhen.aliyuncs.com/img/20220531154914.png" srcset="/img/loading.gif" lazyload alt="image-20220531154914613"></p></li><li><p>根据脚本命令上传本地镜像</p><ul><li><p>首先登录</p><p><img src="https://inencoding.oss-cn-shenzhen.aliyuncs.com/img/20220531155818.png" srcset="/img/loading.gif" lazyload alt="image-20220531155818378"></p></li><li><p>选择 <strong>ID 为 3b15ce0005bd</strong> 的镜像上传</p><p><img src="https://inencoding.oss-cn-shenzhen.aliyuncs.com/img/20220531160346.png" srcset="/img/loading.gif" lazyload alt="image-20220531160346109"></p></li></ul></li></ul><h1 id="将阿里云上的镜像下载到本地"><a href="#将阿里云上的镜像下载到本地" class="headerlink" title="将阿里云上的镜像下载到本地"></a>将阿里云上的镜像下载到本地</h1><p>使用阿里云脚本拉取镜像</p><p><img src="https://inencoding.oss-cn-shenzhen.aliyuncs.com/img/20220531195928.png" srcset="/img/loading.gif" lazyload alt="image-20220531195928935"></p><h1 id="本地镜像发布到私有库"><a href="#本地镜像发布到私有库" class="headerlink" title="本地镜像发布到私有库"></a>本地镜像发布到私有库</h1><ul><li><p>下载镜像 Docker Registry</p><p><img src="https://inencoding.oss-cn-shenzhen.aliyuncs.com/img/20220531211835.png" srcset="/img/loading.gif" lazyload alt="image-20220531211835646"></p></li><li><p>下载成功</p><p><img src="https://inencoding.oss-cn-shenzhen.aliyuncs.com/img/20220531212050.png" srcset="/img/loading.gif" lazyload alt="image-20220531212050828"></p></li><li><p>运行私有库 Registry，相当于本地有个私有 Docker hub</p><p>默认情况，仓库被创建在容器的 /var/lib/registry 目录下，建议自行用容器卷映射，方便于宿主机联调</p><p><code>docker run -d -p 5000:5000 -v /awei/myregistry/:/tmp/registry --privileged=true registry</code></p><p><img src="https://inencoding.oss-cn-shenzhen.aliyuncs.com/img/20220601002833.png" srcset="/img/loading.gif" lazyload alt="image-20220601002833851"></p></li><li><p>创建一个新镜像</p><p><code>docker run -it centos:7 bash</code></p></li><li><p>centos 安装 ifconfig 命令，因为原始的 centos 镜像不带 ifconfig 命令</p><p><code>yum install net-tools</code></p></li><li><p>测试</p><p><img src="https://inencoding.oss-cn-shenzhen.aliyuncs.com/img/20220601011901.png" srcset="/img/loading.gif" lazyload alt="image-20220601011901821"></p></li><li><p>安装完成后，commit 新镜像</p><p><code>docker commit -m="提交的描述信息" -a="作者" 容器ID 要创建的目标镜像名:[标签名]</code></p><p><img src="https://inencoding.oss-cn-shenzhen.aliyuncs.com/img/20220601014235.png" srcset="/img/loading.gif" lazyload alt="image-20220601014235831"></p><p><img src="https://inencoding.oss-cn-shenzhen.aliyuncs.com/img/20220601014205.png" srcset="/img/loading.gif" lazyload alt="image-20220601014205893"></p></li><li><p>启动新镜像并和原来的对比</p><ul><li>官网是默认下载的 Ubuntu 没有 ifconfig 命令</li><li>commit 构建的新镜像，新增加了 ifconfig 功能，可以成功使用</li></ul></li><li><p>curl 验证私服库上有什么镜像</p><p><code>curl -XGET http://宿主机IP:5000/v2/_catalog</code></p><p><img src="https://inencoding.oss-cn-shenzhen.aliyuncs.com/img/20220601012909.png" srcset="/img/loading.gif" lazyload alt="image-20220601012909744"></p><p>发现没有任何镜像</p></li><li><p>将新的镜像修改成符合私服规范的 Tag</p><p><code>docker tag 镜像:Tag Host:Port/Repository:Tag</code></p><p><img src="https://inencoding.oss-cn-shenzhen.aliyuncs.com/img/20220601014911.png" srcset="/img/loading.gif" lazyload alt="image-20220601014911105"></p></li><li><p>修改配置文件使之支持 http</p><p><code>vim /etc/docker/daemon.json</code></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">{<br>  <span class="hljs-string">"registry-mirrors"</span>: [<span class="hljs-string">"阿里云镜像加速网址"</span>],<br>  <span class="hljs-string">"insecure-registries"</span>: [<span class="hljs-string">"宿主机IP:5000"</span>]<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="https://inencoding.oss-cn-shenzhen.aliyuncs.com/img/20220601015242.png" srcset="/img/loading.gif" lazyload alt="image-20220601015241995"></p><p>因为 docker 默认不允许 http 方式推送镜像，通过配置选项来取消这个限制。====&gt; <strong>修改完后如果不生效，建议重启 docker</strong>。</p></li><li><p>push 推送到私服库</p><p><code>docker push 宿主机IP:5000/Repository:Tag</code></p><p><img src="https://inencoding.oss-cn-shenzhen.aliyuncs.com/img/20220601015905.png" srcset="/img/loading.gif" lazyload alt="image-20220601015905433"></p></li><li><p>curl 验证私服库上有什么镜像</p><p><code>curl -XGET http://宿主机IP:5000/v2/_catalog</code></p><p><img src="https://inencoding.oss-cn-shenzhen.aliyuncs.com/img/20220601020037.png" srcset="/img/loading.gif" lazyload alt="image-20220601020037841"></p></li><li><p>pull 到本地并运行</p><p><code>docker pull 宿主机IP:5000/Repository:Tag</code></p><p><img src="https://inencoding.oss-cn-shenzhen.aliyuncs.com/img/20220601020442.png" srcset="/img/loading.gif" lazyload alt="image-20220601020442530"></p><p>运行</p><p><img src="https://inencoding.oss-cn-shenzhen.aliyuncs.com/img/20220601020653.png" srcset="/img/loading.gif" lazyload alt="image-20220601020653585"></p></li></ul><h1 id="Docker容器数据卷"><a href="#Docker容器数据卷" class="headerlink" title="Docker容器数据卷"></a>Docker 容器数据卷</h1><h2 id="首先来个坑"><a href="#首先来个坑" class="headerlink" title="首先来个坑"></a>首先来个坑</h2><p>Docker 挂载主机目录访问如果出现 <strong>cannot open directory : Permission denied</strong></p><p>解决办法：在挂载目录后多加一个 <code>--privileged=true</code> 参数即可</p><p><strong>为什么</strong></p><p>CentOS7 安全模块会比之前系统版本加强，不安全的会先禁止，所以目录挂载的情况被默认为不安全的行为，在 SELinux 里面挂载目录被禁止掉了，如果要开启，我们一般使用 <code>--privileged=true</code> 命令，扩大容器的权限解决挂载目录没有权限的问题，也即使用该参数，container 内的 root 拥有真正的 root 权限，否则，container 内的 root 只是外部的一个普通用户权限。</p><h2 id="是什么-2"><a href="#是什么-2" class="headerlink" title="是什么"></a>是什么</h2><p>卷就是目录或文件，存在于一个或多个容器中，由 docker 挂载到容器，但不属于联合文件系统，因此能够绕过 Union File System 提供一些用于持续存储或共享数据的特性：</p><p>卷的设计目的就是<strong>数据的持久化</strong>，完全独立于容器的生存周期，因此 Docker 不会在容器删除时删除其挂载的数据卷。</p><p>一句话：<strong>将 docker 容器内的数据保存进宿主机的磁盘中</strong>。</p><ul><li><p>运行一个带有容器卷存储功能的容器实例</p><p><code>docker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录 镜像名</code></p></li></ul><h2 id="能干嘛-1"><a href="#能干嘛-1" class="headerlink" title="能干嘛"></a>能干嘛</h2><p>将运用与运行的环境打包镜像，run 后形成容器实例运行 ，但是我们对数据的要求希望是<strong>持久化的</strong></p><p>Docker 容器产生的数据，如果不备份，那么当容器实例删除后，容器内的数据自然也就没有了。</p><p><strong>为了能保存数据在 docker 中我们使用卷</strong>。</p><ul><li>特点<ul><li>数据卷可在容器之间共享或重用数据</li><li>卷中的更改可以直接实时生效</li><li>数据卷中的更改不会包含在镜像的更新中</li><li>数据卷的生命周期一直持续到没有容器使用它为止</li></ul></li></ul><h2 id="数据卷案例"><a href="#数据卷案例" class="headerlink" title="数据卷案例"></a>数据卷案例</h2><ul><li><p>命令：<code>docker run -it -v /宿主机目录:/容器内目录 镜像名 命令</code></p><p><img src="https://inencoding.oss-cn-shenzhen.aliyuncs.com/img/20220601145340.png" srcset="/img/loading.gif" lazyload alt="image-20220601145340290"></p><p>可以看到 <code>/tmp/docker_data</code> 目录底下没有任何文件</p></li><li><p>创建一个文件</p><p><img src="https://inencoding.oss-cn-shenzhen.aliyuncs.com/img/20220601145518.png" srcset="/img/loading.gif" lazyload alt="image-20220601145518697"></p></li><li><p>返回宿主机查看 <code>/tmp/host_data</code> 目录，发现文件已经同步</p><p><img src="https://inencoding.oss-cn-shenzhen.aliyuncs.com/img/20220601145634.png" srcset="/img/loading.gif" lazyload alt="image-20220601145634656"></p></li><li><p>在主机的 <code>/tmp/host_data</code> 目录下创建新的文件</p><p><img src="https://inencoding.oss-cn-shenzhen.aliyuncs.com/img/20220601145835.png" srcset="/img/loading.gif" lazyload alt="image-20220601145835072"></p></li><li><p>返回容器内 <code>/tmp/docker_data</code> 目录，发现文件已经同步</p><p><img src="https://inencoding.oss-cn-shenzhen.aliyuncs.com/img/20220601145953.png" srcset="/img/loading.gif" lazyload alt="image-20220601145953960"></p></li><li><p>使用 <code>docker inspect 容器ID</code> 查看挂载情况</p><p><img src="https://inencoding.oss-cn-shenzhen.aliyuncs.com/img/20220601150115.png" srcset="/img/loading.gif" lazyload alt="image-20220601150115822"></p></li><li><p>容器和宿主机之间数据共享</p><ul><li>docker 修改，主机同步获得</li><li>主机修改，docker 同步获得</li><li>docker 容器 stop，主机修改，docker 容器重启数据也是同步的</li></ul></li></ul><h2 id="读写规则映射添加说明"><a href="#读写规则映射添加说明" class="headerlink" title="读写规则映射添加说明"></a>读写规则映射添加说明</h2><ul><li><p>以上案例默认情况下，权限为：<strong>rw（read + write）</strong></p><p><code>docker run -it -v /宿主机目录:/容器内目录:rw 镜像名 命令</code></p></li><li><p><strong>只读 ro（read only）</strong>： 容器实例内部被限制，只能读取不能写，此时如果宿主机写入内容，可以同步给容器内，容器可以读取到</p><p><code>docker run -it -v /宿主机目录:/容器内目录:ro 镜像名 命令</code></p></li></ul><h2 id="卷的继承和共享"><a href="#卷的继承和共享" class="headerlink" title="卷的继承和共享"></a>卷的继承和共享</h2><ul><li><p>容器 1 完成和宿主机的映射</p><p><code>docker run -it --privileged=true -v /宿主机目录:/容器目录 --name 容器1 镜像名</code></p></li><li><p>容器 2 继承容器 1 的卷规则</p><p><code>docker run -it --privileged=true --volumes-from 父类名字 --name 容器2 镜像名</code></p></li><li><p><strong>可以发现两个容器上拥有相同的文件以及对宿主机的同步</strong></p></li></ul></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="category-chain-item">学习笔记</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/%E5%AE%B9%E5%99%A8/">#容器</a></div></div><div class="license-box my-3"><div class="license-title"><div>Docker</div><div>https://www.inencoding.com/posts/40991/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>AWEI</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2022年5月28日</div></div><div class="license-meta-item license-meta-date"><div>更新于</div><div>2022年12月8日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a><a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="NC - 非商业性使用"><i class="iconfont icon-nc"></i></span></a><a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="SA - 相同方式共享"><i class="iconfont icon-sa"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/posts/62461/" title="python 爬虫"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">python 爬虫</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/posts/42142/" title="插件测试"><span class="hidden-mobile">插件测试</span> <span class="visible-mobile">下一篇</span><i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a><i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a><div><span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span><script src="/js/duration.js"></script></div></div><div class="statistics"><span id="busuanzi_container_site_pv" style="display:none">总访问量<span id="busuanzi_value_site_pv"></span> 次</span> <span id="busuanzi_container_site_uv" style="display:none">总访客数<span id="busuanzi_value_site_uv"></span> 人</span></div><div class="beian"><span><a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">粤ICP备2021025468号</a></span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing;(t=t.getElementById("subtitle"))&&e&&e(t.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",(function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init({tocSelector:"#toc-body",contentSelector:".markdown-body",headingSelector:CONFIG.toc.headingSelector||"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:CONFIG.toc.collapseDepth||0,scrollSmooth:!0,headingsOffset:-t}),0<o.find(".toc-list-item").length&&o.css("visibility","visible"))}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var o,n=[];for(o of(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","))n.push(".markdown-body > "+o.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(n.join(", "))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript><script src="https://fastly.jsdelivr.net/npm/hexo-tag-common@0.1.0/js/index.js"></script><script async>window.onload=function(){var e=document.createElement("script"),t=document.getElementsByTagName("script")[0];e.type="text/javascript",e.async=!0,e.src="/sw-register.js?v="+Date.now(),t.parentNode.insertBefore(e,t)}</script></body></html>